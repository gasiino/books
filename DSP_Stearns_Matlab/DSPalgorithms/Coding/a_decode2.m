function x=a_decode2(y,Nsym,K)
% x=a_decode2(y,Nsym,K)
%
% Adaptive arithmetic decoding of data encoded by a_encode2.
%
% Inputs: y    =uint8 code vector generated by a_encode2.
%         Nsym =# symbols = length of frequency vector.
%         K    =length of output vector x.
%
% Output: x    =decoded vector.
%
% See also: a_encode2, a_encode, a_decode, e_encode2, e_decode2, freq

% Set the word partitions to be the same as in a_encode2.
if Nsym==1,                     %if Nsym=1, the elements of the original
    x=zeros(1,K);               %  vector were all zero.
    return
end
W=44;
t=2^(W/2)-1;
t1=(t+1)/4;
t2=2*t1;
t3=3*t1;

% Initialize the frequency vector.
f=ones(1,Nsym);                 %f =symbol freqencies, initialized to 1.
M=triu(ones(Nsym,Nsym));        %M =array used to compute cum. freqs.

% Initialize for decoding.
L=0;                            %L =lower bound in W
H=t;                            %H =upper bound in W

% ix=index in x; jb=bit location in y; val=working value.
v=2.^[-7:0]';                   %vector used to extract bits from y
ys=single(y');                  %ys =y as a f.p. row vector
jbmax=8*length(ys);             %jbmax =#elements in buffer
if jbmax<W/2,
    Nz=ceil((W/16)-jbmax/8);    %append Nz zeros to ys if necessary
    ys=[ys zeros(1,Nz,'single')];
end
buf=int8(rem(fix(v*ys),2));     %8xNy array. buf(:,1)=8 bits of y(1), etc.
x=zeros(K,1);                   %x becomes the output (column) vector
val=0;
jb=0;                           %jb is the bit counter in buf
for i=1:W/2,
	jb=jb+1;
    val=2*val+double(buf(jb));  %val is the working part of the bit string
end

% Decode loop starts here. sym= current symbol. x(ix)=sym-1.
tic;
for ix=1:K,
%................Uncomment the next 3 lines to print timing...............
%    if rem(ix,50000)==0,
%        t=toc; fprintf('decode ix=%8.0f; t=%8.1f sec\n',ix,t); tic;
%    end
%.........................................................................
    cf=[0 f(1:Nsym)*M];             %update the cum. freqs based on f
    Nx=cf(Nsym+1);                  %Nx =Nsym + ix-1 =sum of freqs.
    R=H-L;
    cfx=fix(((val-L+1)*Nx-1)/R);    %cfx =cf of symbol ix
    i=2;
    while cf(i)<=cfx,
        i=i+1;
    end
    sym=i-1;
    x(ix)=sym-1;
    H=fix(L+(R*cf(sym+1))/Nx - 1);  %adjust H and L as in a_encode
    L=fix(L+(R*cf(sym))/Nx);
% Ensure L < t2 <= H, and (L,H) not in [t1,t3).
    while H<t2 | L>=t2 | (L>=t1 & H<t3),
        if L>=t2
           val=val-t2;
           L=L-t2;
           H=H-t2;
        elseif L>=t1 & H<t3
           val=val-t1;
           L=L-t1;
           H=H-t1;
        end
        if jb<jbmax,
            jb=jb+1;
            val=2*val+double(buf(jb));
        else
            val=2*val;
        end
        L=2*L;
        H=2*H+1;
    end
    f(sym)=f(sym)+1;            %update f for next pass thru loop
end 
